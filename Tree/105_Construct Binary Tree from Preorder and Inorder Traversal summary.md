- 因为每个节点存储的值是唯一的，数组可以用 hash 存储,也可以不用，因为python也可以通过list的index方法通过值找下标。
- 对下标的遍历可以看成对二叉树的遍历，只不过构造二叉树从子节点反向构造，和从根节点遍历是相反的。递归模型抽象出来像是找出一位数组中每个数字范围，类似（（1，2）3）这样，最底层的子节点里面元素的个数应该是大于1小于等于三的，因此通过判断左右节点的个数就可以确定递归条件，
- 每一个数字对应的是二叉树的一个节点，因此最下层的节点一定是挂载两个 None，如果用递归方法，这也是最 trick 的地方，怎么找到返回的判定条件。以前序遍历为例，每次传入的左节点和根节点的位置相当于两个指针，两个指针相遇的时候，这个时候这个节点可以看成有两个 None 子节点的根节点，因此两个左指针小于右指针才是返回 null 的判定条件
  以最小模型【0，1，2】为例子，在找到 1 为根节点后，这个时候，左子树的起点和终点重合了，都是 0，这个时候还不能返回，而是把 0 作为两个 None 的根节点，所以还需要往下掉用一次，返回 null，这个时候判定条件是左指针《右指针。
- 同理我们可以推理出右子树也是一样的返回条件

-必须要通过两个数组，才能判定左右子树的边界