- 因为每个节点存储的值是唯一的，数组可以用 hash 存储,也可以不用，因为 python 也可以通过 list 的 index 方法通过值找下标。
- 对下标的遍历可以看成对二叉树的遍历，只不过构造二叉树从子节点反向构造，和从根节点遍历是相反的。递归模型抽象出来像是找出一位数组中每个数字范围，类似（（1，2）3）这样，最底层的子节点里面元素的个数应该是大于 1 小于等于三的，因此通过判断左右节点的个数就可以确定递归条件，
- 每一个数字对应的是二叉树的一个节点，因此最下层的节点一定是挂载两个 None，
  以最小模型【0，1，2】为例子，在找到 1 为根节点后，这个时候，左子树的起点和终点重合了，都是 0，这个时候还不能返回，而是把 0 作为两个 None 的根节点，所以还需要往下掉用一次，返回 null，这个时候判定条件是左指针《右指针。
- 同理我们可以推理出右子树也是一样的返回条件，为什么不能在两个指针相遇时候直接返回 treeNode（value）？因为一个节点可能出现只有左节点或者只有右节点情况，这样可能会漏掉一个节点

-必须要通过两个数组，才能判定左右子树的边界
