# 15. 3Sum

## Problem Description

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

**Notice:** The solution set must not contain duplicate triplets.

## Constraints

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

## Examples

### Example 1

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```

**Explanation:**
- `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0`
- `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0`
- `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0`

The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

Notice that the order of the output and the order of the triplets does not matter.

### Example 2

```
Input: nums = [0,1,1]
Output: []
```

**Explanation:** The only possible triplet does not sum up to 0.

### Example 3

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
```

**Explanation:** The only possible triplet sums up to 0.

## Solution Approach
破题
先用i做单词遍历，相当于固定一个索引，同时逐渐搜下左右指针移动范围
再用双指针技巧通过三个数字之和等于0这个关键信息进行搜索和判断
因为一次只能移动一个，其中一个隐含条件是如果大了则往左移动，如果小了则l往右移动

### Key Ideas

1. **排序 (Sorting)**: 首先对数组进行排序，使得我们可以使用双指针技巧
2. **固定基准 (Base Index)**: 遍历数组，固定一个基准值 `nums[i]`，然后在剩余数组中寻找两数之和为 `-nums[i]`
3. **双指针 (Two Pointers)**: 对于固定的 `nums[i]`，使用左右指针在剩余有序数组中查找配对

### 去重策略 (Deduplication)

- **第一层去重**: 遍历时如果 `nums[i] == nums[i-1]`，跳过以避免重复计算
- **双指针去重**: 找到一组解后，移动指针时跳过重复元素
- **使用 Set**: 或者利用 set 的性质自动去重

### 优化技巧

- **提前终止**: 当 `nums[i] > 0` 时可以提前终止，因为后续元素都为正数
- **Base Index 条件**: 理想情况下 base index 对应的值应该 `<= 0`

## Complexity Analysis

- **Time Complexity**: O(n²)
  - 排序: O(n log n)
  - 双重循环: O(n²)

- **Space Complexity**: O(1) or O(n)
  - 不考虑返回结果: O(1)
  - 考虑返回结果: O(n)
