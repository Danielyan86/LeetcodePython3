### 思路

- 直接使用内置函数，这题就失去考算法意义了。
- hash + 双向链表实现
- 为什么使用hash+双向链表，因为没有一个现成的数据结构可以满足这个需求，所以相当于实现了一个有序字典
- 当python里面出现一个高级数据结构，有序字典的时候，就可以直接满足了。
- 其实就是可以直接通过字典的key找到node，用空间换时间
- 题目有个隐含条件没有说明，get一次是使用，当put一次key存在时候，也是一次使用，也就是只要key存在，无论如何都是一次use


思路不是很复杂，但是实际实现 code 时候细节很多，很容易出错，需要注意这几点

- 链表里面也需要存一个 key，方便通过 node 获取到字典的 key，可以理解成 hash 和链表的 node 也是双向的
- 初始化头尾哨兵节点，让插入和删除更加方便
- delete 和 add node 的操作可以封装，方便 get 和 put 调用，del 字典操作操作不要放到子方法里，减少冗余
- put 一个已经存在 key 操作因为包括了一个 get 步骤，可以先直接调用 get 方法
- get 不要忘了 return value
- 注意双向链表插入和删除细节
- 注意初始化头尾节点不要指向同一个节点
- - 采用末尾节点为最新的是为了和 ordereddict 方向保持一致

### code

```python
# hash + Doubly linked list
class LinkNode:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.pre = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head, self.tail = LinkNode(), LinkNode()
        self.head.next, self.tail.pre = self.tail, self.head

    def get(self, key: int) -> int:
        if key not in self.cache:
            return -1
        node = self.cache[key]
        self._move_to_tail(node)
        return node.value

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._move_to_tail(node)
        else:
            if len(self.cache) == self.capacity:
                # Remove least recently used (head.next)
                lru_node = self.head.next
                self._remove_node(lru_node)
                del self.cache[lru_node.key]

            # Add new node
            new_node = LinkNode(key, value)
            self.cache[key] = new_node
            self._add_to_tail(new_node)

    def _remove_node(self, node):
        """Remove node from doubly linked list"""
        node.pre.next = node.next
        node.next.pre = node.pre

    def _add_to_tail(self, node):
        """Add node before tail (most recently used position)"""
        node.pre = self.tail.pre
        node.next = self.tail
        self.tail.pre.next = node
        self.tail.pre = node

    def _move_to_tail(self, node):
        """Move existing node to tail (mark as recently used)"""
        self._remove_node(node)
        self._add_to_tail(node)

```

```python
# ordereddict
class LRUCache:
    #let's assume the fist item is the less used due to orderedDict feature
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = OrderedDict()

    def get(self, key: int) -> int:
        if key not in self.cache: return -1
        self.cache.move_to_end(key)
        return self.cache[key]

    def put(self, key: int, value: int) -> None:
        # need to judge the key existing in dictionary d[k]=v is enough
        self.cache[key] = value # add to the end by default
        self.cache.move_to_end(key)
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False) # pop the first item
```

### complexity

Because using the hash table to find the node, the time is constant

- time: O(1) for both get and put operations
- space: O(capacity) to store the cache entries
